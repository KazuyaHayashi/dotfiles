set nocompatible
filetype off

if has('vim_starting')
    set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

call neobundle#rc(expand('~/.vim/bundle/'))

NeoBundle 'git://github.com/Shougo/neobundle.vim.git'
NeoBundle 'git://github.com/Shougo/neocomplcache.git'
NeoBundle 'git://github.com/Shougo/neosnippet.git'
NeoBundle 'git://github.com/Shougo/unite.vim.git'
NeoBundle 'git://github.com/Shougo/vimproc.git' 
NeoBundle 'git://github.com/Shougo/unite-ssh.git'
NeoBundle 'git://github.com/tpope/vim-surround.git'
NeoBundle 'git://github.com/scrooloose/nerdtree.git'
NeoBundle 'git://github.com/vim-scripts/taglist.vim.git'
NeoBundle 'git://github.com/h1mesuke/vim-alignta.git'
NeoBundle 'tagexplorer.vim'
NeoBundle 'taglist-plus'
NeoBundle "git://github.com/thinca/vim-quickrun.git"
NeoBundle 'git://github.com/thinca/vim-ref.git'
NeoBundle 'git://github.com/yuratomo/w3m.vim.git'
NeoBundle 'git://github.com/nvie/vim-flake8.git'
NeoBundle 'git://github.com/tpope/vim-fugitive.git'
NeoBundle 'git://github.com/Lokaltog/vim-easymotion.git'
filetype plugin indent on


" bell setting
set visualbell
" editer action
set autoread
set backspace=indent,eol,start
set hidden
" display setting
syntax on
set title
set statusline=%n\:%y%F\ \|%{(&fenc!=''?&fenc:&enc).'\|'.&ff.'\|'}%m%r\ %{strftime('%c')}%=<%l/%L:%p%%>
set laststatus=2
set cmdheight=2
set showcmd
" tab 
set autoindent
set smartindent
set shiftwidth=4
set tabstop=4
set softtabstop=4
set smarttab
set expandtab
" menu select
set wildmode=longest,list
" encoding
set fileencodings=utf-8,iso-2022-jp,sjis,euc-jp
set encoding=utf-8
" search
set ignorecase
set smartcase
set wrapscan
set hlsearch
set showmatch
"" search key mapping
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz
"" vimrc reload and edit 
nnoremap <silent> <C-r>s :source $HOME/.vimrc<Enter>
nnoremap <silent> <C-r>e :tabnew $HOME/.vimrc<Enter>
" vim のヘルプを検索する
function! Vimhelp(word)
    execute ":h" a:word
endfunction
" vimrc を開いた時だけキーバインドが設定されるようにする 
autocmd FileType vim nnoremap <buffer> <silent> <C-h><C-v> :call Vimhelp(expand('<cword>'))<Enter>


""" plugin setting
" taglist
    let Tlist_Ctags_Cmd = "/usr/bin/ctags"
    let Tlist_Show_One_File = 1
    let Tlist_Exit_OnlyWindow = 1
    map <silent><leader>tl :TlistToggle<cr>
" tagexplorer
    let TE_Ctags_Path = "/usr/bin/ctags"
" NERDTree
    let NERDTreeQuitOnOpen = 1
    let NERDTreeShowHidden = 1 
" neocomplcache
    "Note: This option must set it in .vimrc(_vimrc). NOT IN .gvimrc(_gvimrc)!
    " Disable AutoComplPop.
    let g:acp_enableAtStartup = 0
    " Use neocomplcache.
    let g:neocomplcache_enable_at_startup = 1
    " Use smartcase.
    let g:neocomplcache_enable_smart_case = 1
    " Use camel case completion.
    let g:neocomplcache_enable_camel_case_completion = 0
    " Use underbar completion.
    let g:neocomplcache_enable_underbar_completion = 1
    " Set minimum syntax keyword length.
    let g:neocomplcache_min_syntax_length = 3
    let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

    " Define dictionary.
    let g:neocomplcache_dictionary_filetype_lists = {
        \ 'default' : '',
        \ 'vimshell' : $HOME.'/.vimshell_hist',
        \ 'scheme' : $HOME.'/.gosh_completions'
            \ }

    " Define keyword.
    if !exists('g:neocomplcache_keyword_patterns')
        let g:neocomplcache_keyword_patterns = {}
    endif
    let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

    " Plugin key-mappings.
    inoremap <expr><C-g>     neocomplcache#undo_completion()
    inoremap <expr><C-l>     neocomplcache#complete_common_string()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
      return neocomplcache#smart_close_popup() . "\<CR>"
      " For no inserting <CR> key.
      "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
    endfunction
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplcache#close_popup()
    inoremap <expr><C-e>  neocomplcache#cancel_popup()

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    " Enable heavy omni completion.
    if !exists('g:neocomplcache_omni_patterns')
      let g:neocomplcache_omni_patterns = {}
    endif
    let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
    "autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
    let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

    " For perlomni.vim setting.
    " https://github.com/c9s/perlomni.vim
    let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
" unite.vim
	" The prefix key.
	nnoremap    [unite]   <Nop>
	nmap    f [unite]
	
	nnoremap <silent> [unite]c  :<C-u>UniteWithCurrentDir
	\ -buffer-name=files buffer file_mru bookmark file<CR>
	nnoremap <silent> [unite]b  :<C-u>UniteWithBufferDir
	\ -buffer-name=files -prompt=%\  buffer file_mru bookmark file<CR>
	nnoremap <silent> [unite]r  :<C-u>Unite
	\ -buffer-name=register register<CR>
	nnoremap <silent> [unite]o  :<C-u>Unite outline<CR>
	nnoremap <silent> [unite]f
	\ :<C-u>Unite -buffer-name=resume resume<CR>
	nnoremap <silent> [unite]d
	\ :<C-u>Unite -buffer-name=files -default-action=lcd directory_mru<CR>
	nnoremap <silent> [unite]ma
	\ :<C-u>Unite mapping<CR>
	nnoremap <silent> [unite]me
	\ :<C-u>Unite output:message<CR>
	nnoremap  [unite]f  :<C-u>Unite source<CR>
	
	nnoremap <silent> [unite]s
	        \ :<C-u>Unite -buffer-name=files -no-split
	        \ jump_point file_point buffer_tab
	        \ file_rec:! file file/new file_mru<CR>
	
	" Start insert.
	"let g:unite_enable_start_insert = 1
	"let g:unite_enable_short_source_names = 1
	
	autocmd FileType unite call s:unite_my_settings()
	function! s:unite_my_settings()"{{{
	  " Overwrite settings.
	
	  nmap <buffer> <ESC>      <Plug>(unite_exit)
	  imap <buffer> jj      <Plug>(unite_insert_leave)
	  "imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)
	
	imap <buffer><expr> j unite#smart_map('j', '')
	imap <buffer> <TAB>   <Plug>(unite_select_next_line)
	imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)
	imap <buffer> '     <Plug>(unite_quick_match_default_action)
	nmap <buffer> '     <Plug>(unite_quick_match_default_action)
	imap <buffer><expr> x
	        \ unite#smart_map('x', "\<Plug>(unite_quick_match_choose_action)")
	nmap <buffer> x     <Plug>(unite_quick_match_choose_action)
	nmap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
	imap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
	imap <buffer> <C-y>     <Plug>(unite_narrowing_path)
	nmap <buffer> <C-y>     <Plug>(unite_narrowing_path)
	nmap <buffer> <C-j>     <Plug>(unite_toggle_auto_preview)
	nmap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
	imap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
	nnoremap <silent><buffer><expr> l
	        \ unite#smart_map('l', unite#do_action('default'))
	
	let unite = unite#get_current_unite()
	if unite.buffer_name =~# '^search'
	  nnoremap <silent><buffer><expr> r     unite#do_action('replace')
	else
	  nnoremap <silent><buffer><expr> r     unite#do_action('rename')
	endif
	
	nnoremap <silent><buffer><expr> cd     unite#do_action('lcd')
	nnoremap <buffer><expr> S      unite#mappings#set_current_filters(
	\ empty(unite#mappings#get_current_filters()) ? ['sorter_reverse'] : [])
	endfunction"}}}
	
	let g:unite_source_file_mru_limit = 200
	let g:unite_cursor_line_highlight = 'TabLineSel'
	let g:unite_abbr_highlight = 'TabLine'
	
	" For optimize.
	let g:unite_source_file_mru_filename_format = ''
	
	if executable('jvgrep')
	  " For jvgrep.
	  let g:unite_source_grep_command = 'jvgrep'
	  let g:unite_source_grep_default_opts = '--exclude ''\.(git|svn|hg|bzr)'''
	  let g:unite_source_grep_recursive_opt = '-R'
	endif
	
	" For ack.
	if executable('ack-grep')
	  " let g:unite_source_grep_command = 'ack-grep'
	  " let g:unite_source_grep_default_opts = '--no-heading --no-color -a'
	  " let g:unite_source_grep_recursive_opt = ''
	endif
" neosnippet
	" Plugin key-mappings.
	imap <C-k>     <Plug>(neosnippet_expand_or_jump)
	smap <C-k>     <Plug>(neosnippet_expand_or_jump)
	xmap <C-k>     <Plug>(neosnippet_expand_target)
	xmap <C-l>     <Plug>(neosnippet_start_unite_snippet_target)

	" SuperTab like snippets behavior.
	"imap <expr><TAB> neosnippet#expandable() ?
	" \ "\<Plug>(neosnippet_expand_or_jump)"
	" \: pumvisible() ? "\<C-n>" : "\<TAB>"
	"smap <expr><TAB> neosnippet#expandable() ?
	" \ "\<Plug>(neosnippet_expand_or_jump)"
	" \: "\<TAB>"

	" For snippet_complete marker.
	if has('conceal')
	  set conceallevel=2 concealcursor=i
	endif
	
	" Enable snipMate compatibility feature.
	" let g:neosnippet#enable_snipmate_compatibility = 1

autocmd BufWritePre * :%s/\s\+$//ge

set list
set lcs=tab:>.,trail:_,extends:\
highlight SpecialKey cterm=NONE ctermfg=7 guifg=7
highlight JpSpace cterm=underline ctermfg=14 guifg=14
au BufRead,BufNew * match JpSpace /　/
